// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: blackfury/maker/v1/maker.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BackingRiskParams represents an object of backing coin risk parameters.
type BackingRiskParams struct {
	// backing coin denom
	BackingDenom string `protobuf:"bytes,1,opt,name=backing_denom,json=backingDenom,proto3" json:"backing_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total backing amount
	MaxBacking *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_backing,json=maxBacking,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_backing,omitempty"`
	// maximum mintable Black amount
	MaxMerMint *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=max_mer_mint,json=maxMerMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_mer_mint,omitempty"`
	// mint fee rate
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// burn fee rate
	BurnFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=burn_fee,json=burnFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_fee,omitempty"`
	// buyback fee rate
	BuybackFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=buyback_fee,json=buybackFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"buyback_fee,omitempty"`
	// reback fee rate
	RebackFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=reback_fee,json=rebackFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reback_fee,omitempty"`
}

func (m *BackingRiskParams) Reset()         { *m = BackingRiskParams{} }
func (m *BackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BackingRiskParams) ProtoMessage()    {}
func (*BackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{0}
}
func (m *BackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackingRiskParams.Merge(m, src)
}
func (m *BackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BackingRiskParams proto.InternalMessageInfo

func (m *BackingRiskParams) GetBackingDenom() string {
	if m != nil {
		return m.BackingDenom
	}
	return ""
}

func (m *BackingRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// CollateralRiskParams represents an object of collateral risk parameters.
type CollateralRiskParams struct {
	// collateral coin denom
	CollateralDenom string `protobuf:"bytes,1,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total collateral amount; empty means no limit
	MaxCollateral *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_collateral,json=maxCollateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_collateral,omitempty"`
	// maximum total mintable Black amount; empty means no limit
	MaxMerMint *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=max_mer_mint,json=maxMerMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_mer_mint,omitempty"`
	// ratio at which a position is defined as undercollateralized
	LiquidationThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=liquidation_threshold,json=liquidationThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_threshold,omitempty"`
	// maximum ratio of maximum amount of currency that can be borrowed with a
	// specific collateral
	LoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=loan_to_value,json=loanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"loan_to_value,omitempty"`
	// basic ratio of maximum amount of currency that can be borrowed with a
	// specific collateral
	BasicLoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=basic_loan_to_value,json=basicLoanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"basic_loan_to_value,omitempty"`
	// catalytic ratio of collateralized Fury to asset, to maximize the LTV
	// in [basic-LTV, LTV]
	CatalyticFuryRatio *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=catalytic_fury_ratio,json=catalyticFuryRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"catalytic_fury_ratio,omitempty"`
	// liquidation fee rate, i.e., the discount a liquidator gets when buying
	// collateral flagged for a liquidation
	LiquidationFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=liquidation_fee,json=liquidationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_fee,omitempty"`
	// mint fee rate, i.e., extra fee debt
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// annual interest fee rate (APR)
	InterestFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=interest_fee,json=interestFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"interest_fee,omitempty"`
}

func (m *CollateralRiskParams) Reset()         { *m = CollateralRiskParams{} }
func (m *CollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*CollateralRiskParams) ProtoMessage()    {}
func (*CollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{1}
}
func (m *CollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollateralRiskParams.Merge(m, src)
}
func (m *CollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *CollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_CollateralRiskParams proto.InternalMessageInfo

func (m *CollateralRiskParams) GetCollateralDenom() string {
	if m != nil {
		return m.CollateralDenom
	}
	return ""
}

func (m *CollateralRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// RegisterBackingProposal is a gov Content type to register eligible
// strong-backing asset with backing risk parameters.
type RegisterBackingProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *RegisterBackingProposal) Reset()         { *m = RegisterBackingProposal{} }
func (m *RegisterBackingProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterBackingProposal) ProtoMessage()    {}
func (*RegisterBackingProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{2}
}
func (m *RegisterBackingProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterBackingProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterBackingProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterBackingProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterBackingProposal.Merge(m, src)
}
func (m *RegisterBackingProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterBackingProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterBackingProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterBackingProposal proto.InternalMessageInfo

func (m *RegisterBackingProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterBackingProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterBackingProposal) GetRiskParams() BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return BackingRiskParams{}
}

// RegisterCollateralProposal is a gov Content type to register eligible
// collateral with collateral risk parameters.
type RegisterCollateralProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *RegisterCollateralProposal) Reset()         { *m = RegisterCollateralProposal{} }
func (m *RegisterCollateralProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterCollateralProposal) ProtoMessage()    {}
func (*RegisterCollateralProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{3}
}
func (m *RegisterCollateralProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterCollateralProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterCollateralProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterCollateralProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterCollateralProposal.Merge(m, src)
}
func (m *RegisterCollateralProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterCollateralProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterCollateralProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterCollateralProposal proto.InternalMessageInfo

func (m *RegisterCollateralProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterCollateralProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterCollateralProposal) GetRiskParams() CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return CollateralRiskParams{}
}

// SetBackingRiskParamsProposal is a gov Content type to set backing coin risk
// parameters.
type SetBackingRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *SetBackingRiskParamsProposal) Reset()         { *m = SetBackingRiskParamsProposal{} }
func (m *SetBackingRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*SetBackingRiskParamsProposal) ProtoMessage()    {}
func (*SetBackingRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{4}
}
func (m *SetBackingRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBackingRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBackingRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetBackingRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBackingRiskParamsProposal.Merge(m, src)
}
func (m *SetBackingRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetBackingRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBackingRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetBackingRiskParamsProposal proto.InternalMessageInfo

func (m *SetBackingRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetBackingRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetBackingRiskParamsProposal) GetRiskParams() BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return BackingRiskParams{}
}

// SetCollateralRiskParamsProposal is a gov Content type to set collateral risk
// parameters.
type SetCollateralRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *SetCollateralRiskParamsProposal) Reset()         { *m = SetCollateralRiskParamsProposal{} }
func (m *SetCollateralRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*SetCollateralRiskParamsProposal) ProtoMessage()    {}
func (*SetCollateralRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{5}
}
func (m *SetCollateralRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCollateralRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCollateralRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCollateralRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCollateralRiskParamsProposal.Merge(m, src)
}
func (m *SetCollateralRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetCollateralRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCollateralRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetCollateralRiskParamsProposal proto.InternalMessageInfo

func (m *SetCollateralRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetCollateralRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetCollateralRiskParamsProposal) GetRiskParams() CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return CollateralRiskParams{}
}

type BatchBackingRiskParams struct {
	// batch of collateral risk params
	RiskParams []BackingRiskParams `protobuf:"bytes,1,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchBackingRiskParams) Reset()         { *m = BatchBackingRiskParams{} }
func (m *BatchBackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BatchBackingRiskParams) ProtoMessage()    {}
func (*BatchBackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{6}
}
func (m *BatchBackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchBackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchBackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchBackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchBackingRiskParams.Merge(m, src)
}
func (m *BatchBackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BatchBackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchBackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BatchBackingRiskParams proto.InternalMessageInfo

func (m *BatchBackingRiskParams) GetRiskParams() []BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetBackingRiskParamsProposal is a gov Content type to batch set backing
// coin risk parameters.
type BatchSetBackingRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []BackingRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchSetBackingRiskParamsProposal) Reset()         { *m = BatchSetBackingRiskParamsProposal{} }
func (m *BatchSetBackingRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*BatchSetBackingRiskParamsProposal) ProtoMessage()    {}
func (*BatchSetBackingRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{7}
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetBackingRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBackingRiskParamsProposal.Merge(m, src)
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetBackingRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBackingRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBackingRiskParamsProposal proto.InternalMessageInfo

func (m *BatchSetBackingRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetBackingRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetBackingRiskParamsProposal) GetRiskParams() []BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

type BatchCollateralRiskParams struct {
	// batch of collateral risk params
	RiskParams []CollateralRiskParams `protobuf:"bytes,1,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchCollateralRiskParams) Reset()         { *m = BatchCollateralRiskParams{} }
func (m *BatchCollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*BatchCollateralRiskParams) ProtoMessage()    {}
func (*BatchCollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{8}
}
func (m *BatchCollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchCollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchCollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchCollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCollateralRiskParams.Merge(m, src)
}
func (m *BatchCollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BatchCollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCollateralRiskParams proto.InternalMessageInfo

func (m *BatchCollateralRiskParams) GetRiskParams() []CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetCollateralRiskParamsProposal is a gov Content type to batch set
// collateral risk parameters.
type BatchSetCollateralRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []CollateralRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchSetCollateralRiskParamsProposal) Reset()         { *m = BatchSetCollateralRiskParamsProposal{} }
func (m *BatchSetCollateralRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*BatchSetCollateralRiskParamsProposal) ProtoMessage()    {}
func (*BatchSetCollateralRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{9}
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetCollateralRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetCollateralRiskParamsProposal.Merge(m, src)
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetCollateralRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetCollateralRiskParamsProposal proto.InternalMessageInfo

func (m *BatchSetCollateralRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetCollateralRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetCollateralRiskParamsProposal) GetRiskParams() []CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

type TotalBacking struct {
	// total backing value in uUSD
	BackingValue github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=backing_value,json=backingValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"backing_value"`
	// total minted black; negative value means burned black
	MerMinted types.Coin `protobuf:"bytes,2,opt,name=mer_minted,json=merMinted,proto3" json:"mer_minted"`
	// total burned fury; negative value means minted fury
	FuryBurned types.Coin `protobuf:"bytes,3,opt,name=fury_burned,json=furyBurned,proto3" json:"fury_burned"`
}

func (m *TotalBacking) Reset()         { *m = TotalBacking{} }
func (m *TotalBacking) String() string { return proto.CompactTextString(m) }
func (*TotalBacking) ProtoMessage()    {}
func (*TotalBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{10}
}
func (m *TotalBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalBacking.Merge(m, src)
}
func (m *TotalBacking) XXX_Size() int {
	return m.Size()
}
func (m *TotalBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalBacking.DiscardUnknown(m)
}

var xxx_messageInfo_TotalBacking proto.InternalMessageInfo

func (m *TotalBacking) GetMerMinted() types.Coin {
	if m != nil {
		return m.MerMinted
	}
	return types.Coin{}
}

func (m *TotalBacking) GetFuryBurned() types.Coin {
	if m != nil {
		return m.FuryBurned
	}
	return types.Coin{}
}

type PoolBacking struct {
	// total minted black; negative value means burned black
	MerMinted types.Coin `protobuf:"bytes,1,opt,name=mer_minted,json=merMinted,proto3" json:"mer_minted"`
	// total backing
	Backing types.Coin `protobuf:"bytes,2,opt,name=backing,proto3" json:"backing"`
	// total burned fury; negative value means minted fury
	FuryBurned types.Coin `protobuf:"bytes,3,opt,name=fury_burned,json=furyBurned,proto3" json:"fury_burned"`
}

func (m *PoolBacking) Reset()         { *m = PoolBacking{} }
func (m *PoolBacking) String() string { return proto.CompactTextString(m) }
func (*PoolBacking) ProtoMessage()    {}
func (*PoolBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{11}
}
func (m *PoolBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolBacking.Merge(m, src)
}
func (m *PoolBacking) XXX_Size() int {
	return m.Size()
}
func (m *PoolBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolBacking.DiscardUnknown(m)
}

var xxx_messageInfo_PoolBacking proto.InternalMessageInfo

func (m *PoolBacking) GetMerMinted() types.Coin {
	if m != nil {
		return m.MerMinted
	}
	return types.Coin{}
}

func (m *PoolBacking) GetBacking() types.Coin {
	if m != nil {
		return m.Backing
	}
	return types.Coin{}
}

func (m *PoolBacking) GetFuryBurned() types.Coin {
	if m != nil {
		return m.FuryBurned
	}
	return types.Coin{}
}

type AccountBacking struct {
}

func (m *AccountBacking) Reset()         { *m = AccountBacking{} }
func (m *AccountBacking) String() string { return proto.CompactTextString(m) }
func (*AccountBacking) ProtoMessage()    {}
func (*AccountBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{12}
}
func (m *AccountBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountBacking.Merge(m, src)
}
func (m *AccountBacking) XXX_Size() int {
	return m.Size()
}
func (m *AccountBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountBacking.DiscardUnknown(m)
}

var xxx_messageInfo_AccountBacking proto.InternalMessageInfo

type TotalCollateral struct {
	// total existing black debt, including minted by collateral, mint fee, last
	// interest
	MerDebt types.Coin `protobuf:"bytes,1,opt,name=mer_debt,json=merDebt,proto3" json:"mer_debt"`
	// total collateralized fury
	FuryCollateralized types.Coin `protobuf:"bytes,2,opt,name=fury_collateralized,json=furyCollateralized,proto3" json:"fury_collateralized"`
}

func (m *TotalCollateral) Reset()         { *m = TotalCollateral{} }
func (m *TotalCollateral) String() string { return proto.CompactTextString(m) }
func (*TotalCollateral) ProtoMessage()    {}
func (*TotalCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{13}
}
func (m *TotalCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalCollateral.Merge(m, src)
}
func (m *TotalCollateral) XXX_Size() int {
	return m.Size()
}
func (m *TotalCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_TotalCollateral proto.InternalMessageInfo

func (m *TotalCollateral) GetMerDebt() types.Coin {
	if m != nil {
		return m.MerDebt
	}
	return types.Coin{}
}

func (m *TotalCollateral) GetFuryCollateralized() types.Coin {
	if m != nil {
		return m.FuryCollateralized
	}
	return types.Coin{}
}

type PoolCollateral struct {
	// total collateral
	Collateral types.Coin `protobuf:"bytes,1,opt,name=collateral,proto3" json:"collateral"`
	// total existing black debt, including minted by collateral, mint fee, last
	// interest
	MerDebt types.Coin `protobuf:"bytes,2,opt,name=mer_debt,json=merDebt,proto3" json:"mer_debt"`
	// total collateralized fury
	FuryCollateralized types.Coin `protobuf:"bytes,3,opt,name=fury_collateralized,json=furyCollateralized,proto3" json:"fury_collateralized"`
}

func (m *PoolCollateral) Reset()         { *m = PoolCollateral{} }
func (m *PoolCollateral) String() string { return proto.CompactTextString(m) }
func (*PoolCollateral) ProtoMessage()    {}
func (*PoolCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{14}
}
func (m *PoolCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolCollateral.Merge(m, src)
}
func (m *PoolCollateral) XXX_Size() int {
	return m.Size()
}
func (m *PoolCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_PoolCollateral proto.InternalMessageInfo

func (m *PoolCollateral) GetCollateral() types.Coin {
	if m != nil {
		return m.Collateral
	}
	return types.Coin{}
}

func (m *PoolCollateral) GetMerDebt() types.Coin {
	if m != nil {
		return m.MerDebt
	}
	return types.Coin{}
}

func (m *PoolCollateral) GetFuryCollateralized() types.Coin {
	if m != nil {
		return m.FuryCollateralized
	}
	return types.Coin{}
}

type AccountCollateral struct {
	// account who owns collateral
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// existing collateral
	Collateral types.Coin `protobuf:"bytes,2,opt,name=collateral,proto3" json:"collateral"`
	// remaining black debt, including minted by collateral, mint fee, last
	// interest
	MerDebt types.Coin `protobuf:"bytes,3,opt,name=mer_debt,json=merDebt,proto3" json:"mer_debt"`
	// total collateralized fury
	FuryCollateralized types.Coin `protobuf:"bytes,4,opt,name=fury_collateralized,json=furyCollateralized,proto3" json:"fury_collateralized"`
	// remaining interest debt at last settlement
	LastInterest types.Coin `protobuf:"bytes,5,opt,name=last_interest,json=lastInterest,proto3" json:"last_interest"`
	// the block of last settlement
	LastSettlementBlock int64 `protobuf:"varint,6,opt,name=last_settlement_block,json=lastSettlementBlock,proto3" json:"last_settlement_block,omitempty"`
}

func (m *AccountCollateral) Reset()         { *m = AccountCollateral{} }
func (m *AccountCollateral) String() string { return proto.CompactTextString(m) }
func (*AccountCollateral) ProtoMessage()    {}
func (*AccountCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5319d55af8eebdc, []int{15}
}
func (m *AccountCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountCollateral.Merge(m, src)
}
func (m *AccountCollateral) XXX_Size() int {
	return m.Size()
}
func (m *AccountCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_AccountCollateral proto.InternalMessageInfo

func (m *AccountCollateral) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *AccountCollateral) GetCollateral() types.Coin {
	if m != nil {
		return m.Collateral
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetMerDebt() types.Coin {
	if m != nil {
		return m.MerDebt
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetFuryCollateralized() types.Coin {
	if m != nil {
		return m.FuryCollateralized
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetLastInterest() types.Coin {
	if m != nil {
		return m.LastInterest
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetLastSettlementBlock() int64 {
	if m != nil {
		return m.LastSettlementBlock
	}
	return 0
}

func init() {
	proto.RegisterType((*BackingRiskParams)(nil), "blackfury.maker.v1.BackingRiskParams")
	proto.RegisterType((*CollateralRiskParams)(nil), "blackfury.maker.v1.CollateralRiskParams")
	proto.RegisterType((*RegisterBackingProposal)(nil), "blackfury.maker.v1.RegisterBackingProposal")
	proto.RegisterType((*RegisterCollateralProposal)(nil), "blackfury.maker.v1.RegisterCollateralProposal")
	proto.RegisterType((*SetBackingRiskParamsProposal)(nil), "blackfury.maker.v1.SetBackingRiskParamsProposal")
	proto.RegisterType((*SetCollateralRiskParamsProposal)(nil), "blackfury.maker.v1.SetCollateralRiskParamsProposal")
	proto.RegisterType((*BatchBackingRiskParams)(nil), "blackfury.maker.v1.BatchBackingRiskParams")
	proto.RegisterType((*BatchSetBackingRiskParamsProposal)(nil), "blackfury.maker.v1.BatchSetBackingRiskParamsProposal")
	proto.RegisterType((*BatchCollateralRiskParams)(nil), "blackfury.maker.v1.BatchCollateralRiskParams")
	proto.RegisterType((*BatchSetCollateralRiskParamsProposal)(nil), "blackfury.maker.v1.BatchSetCollateralRiskParamsProposal")
	proto.RegisterType((*TotalBacking)(nil), "blackfury.maker.v1.TotalBacking")
	proto.RegisterType((*PoolBacking)(nil), "blackfury.maker.v1.PoolBacking")
	proto.RegisterType((*AccountBacking)(nil), "blackfury.maker.v1.AccountBacking")
	proto.RegisterType((*TotalCollateral)(nil), "blackfury.maker.v1.TotalCollateral")
	proto.RegisterType((*PoolCollateral)(nil), "blackfury.maker.v1.PoolCollateral")
	proto.RegisterType((*AccountCollateral)(nil), "blackfury.maker.v1.AccountCollateral")
}

func init() { proto.RegisterFile("blackfury/maker/v1/maker.proto", fileDescriptor_e5319d55af8eebdc) }

var fileDescriptor_e5319d55af8eebdc = []byte{
	// 1033 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0x9b, 0x6c, 0xd3, 0x3c, 0xa7, 0xed, 0xee, 0x34, 0xbb, 0x64, 0x2b, 0x94, 0x96, 0xe5,
	0x87, 0x0a, 0x12, 0x8e, 0x52, 0x4e, 0xec, 0x81, 0x1f, 0x69, 0xa9, 0x54, 0xb5, 0x65, 0x8b, 0x53,
	0x21, 0x81, 0x90, 0xac, 0xb1, 0x33, 0x9b, 0x8e, 0x62, 0x7b, 0xc2, 0x78, 0x52, 0x35, 0xfc, 0x15,
	0x5c, 0xb9, 0x71, 0xe1, 0x02, 0x07, 0xb8, 0xf0, 0x3f, 0xec, 0xb1, 0x37, 0x10, 0x87, 0x15, 0x6a,
	0x85, 0x84, 0xc4, 0xbf, 0xc0, 0x01, 0xcd, 0x78, 0x9c, 0x38, 0xdb, 0xa0, 0x8d, 0x93, 0x68, 0xb5,
	0xa7, 0xc6, 0x6f, 0xfc, 0x7d, 0xfd, 0xde, 0x9b, 0xf7, 0x66, 0x3e, 0x43, 0xd5, 0xf5, 0xb1, 0xd7,
	0x79, 0xdc, 0xe3, 0xfd, 0x5a, 0x80, 0x3b, 0x84, 0xd7, 0xce, 0xeb, 0xf1, 0x0f, 0xab, 0xcb, 0x99,
	0x60, 0x08, 0x0d, 0xd6, 0xad, 0x38, 0x7c, 0x5e, 0xdf, 0x28, 0xb7, 0x59, 0x9b, 0xa9, 0xe5, 0x9a,
	0xfc, 0x15, 0xbf, 0xb9, 0x51, 0xf5, 0x58, 0x14, 0xb0, 0xa8, 0xe6, 0xe2, 0x88, 0xd4, 0xce, 0xeb,
	0x2e, 0x11, 0xb8, 0x5e, 0xf3, 0x18, 0x0d, 0xe3, 0xf5, 0x07, 0xdf, 0xe5, 0xe1, 0x4e, 0x03, 0x7b,
	0x1d, 0x1a, 0xb6, 0x6d, 0x1a, 0x75, 0x4e, 0x30, 0xc7, 0x41, 0x84, 0x5e, 0x87, 0x15, 0x37, 0x0e,
	0x3a, 0x2d, 0x12, 0xb2, 0xa0, 0x62, 0x6c, 0x19, 0xdb, 0x45, 0xbb, 0xa4, 0x83, 0x7b, 0x32, 0x86,
	0x2a, 0x50, 0x20, 0x21, 0x76, 0x7d, 0xd2, 0xaa, 0x2c, 0x6e, 0x19, 0xdb, 0xcb, 0x76, 0xf2, 0x88,
	0x0e, 0xc1, 0x0c, 0xf0, 0x85, 0xa3, 0xdf, 0xae, 0xe4, 0x24, 0xb8, 0xf1, 0xce, 0x1f, 0x4f, 0x37,
	0xdf, 0x6a, 0x53, 0x71, 0xd6, 0x73, 0x2d, 0x8f, 0x05, 0x35, 0x2d, 0x2c, 0xfe, 0xf3, 0x6e, 0xd4,
	0xea, 0xd4, 0x44, 0xbf, 0x4b, 0x22, 0xeb, 0x20, 0x14, 0x36, 0x04, 0xf8, 0x42, 0xab, 0x42, 0x47,
	0x50, 0x92, 0x64, 0x01, 0xe1, 0x4e, 0x40, 0x43, 0x51, 0xc9, 0x4f, 0xc5, 0x76, 0x4c, 0xf8, 0x31,
	0x0d, 0x05, 0xfa, 0x04, 0x96, 0x25, 0x8b, 0xf3, 0x98, 0x90, 0xca, 0xad, 0x4c, 0x4c, 0x7b, 0xc4,
	0xb3, 0x0b, 0x12, 0xbb, 0x4f, 0x88, 0xa4, 0x71, 0x7b, 0x3c, 0x54, 0x34, 0x4b, 0xd9, 0x69, 0x24,
	0x56, 0xd2, 0x1c, 0x82, 0xe9, 0xf6, 0xfa, 0xb2, 0x4e, 0x8a, 0xa9, 0x90, 0x99, 0x09, 0x34, 0x5c,
	0x92, 0x1d, 0x00, 0x70, 0x32, 0xe0, 0x5a, 0xce, 0xcc, 0x55, 0x8c, 0xd1, 0xfb, 0x84, 0x3c, 0xcc,
	0xff, 0xfd, 0xfd, 0xe6, 0xc2, 0x83, 0xdf, 0x96, 0xa0, 0xbc, 0xcb, 0x7c, 0x1f, 0x0b, 0xc2, 0xb1,
	0x9f, 0x6a, 0x8f, 0xb7, 0xe1, 0xb6, 0x37, 0x88, 0x8f, 0x74, 0xc8, 0xda, 0x30, 0xfe, 0xbc, 0x26,
	0xf9, 0x0c, 0x56, 0xe5, 0xbe, 0x0e, 0x01, 0x53, 0xf4, 0xc9, 0x4a, 0x80, 0x2f, 0x86, 0x0a, 0xe7,
	0xdc, 0x2a, 0x0e, 0xdc, 0xf5, 0xe9, 0xd7, 0x3d, 0xda, 0xc2, 0x82, 0xb2, 0xd0, 0x11, 0x67, 0x9c,
	0x44, 0x67, 0xcc, 0x6f, 0x4d, 0xd1, 0x37, 0xe5, 0x14, 0xd1, 0x69, 0xc2, 0x83, 0x3e, 0x85, 0x15,
	0x9f, 0xe1, 0xd0, 0x11, 0xcc, 0x39, 0xc7, 0x7e, 0x6f, 0x9a, 0x4e, 0x32, 0x25, 0xc1, 0x29, 0xfb,
	0x5c, 0xc2, 0xd1, 0x17, 0xb0, 0xee, 0xe2, 0x88, 0x7a, 0xce, 0x28, 0x6b, 0xf6, 0xae, 0xba, 0xad,
	0x68, 0x8e, 0x52, 0xd4, 0x5f, 0x41, 0xd9, 0xc3, 0x02, 0xfb, 0x7d, 0x41, 0x3d, 0x47, 0x9e, 0x3b,
	0x0e, 0x97, 0xc9, 0x4c, 0xd1, 0x65, 0x68, 0xc0, 0xb3, 0xdf, 0xe3, 0x7d, 0x5b, 0xb2, 0xa0, 0x26,
	0xac, 0xa5, 0x2b, 0x2d, 0xdb, 0xb7, 0x98, 0x99, 0x78, 0x35, 0x45, 0xa1, 0x47, 0x74, 0x30, 0xe9,
	0x30, 0xfd, 0xa4, 0x1f, 0x43, 0x89, 0x86, 0x82, 0x70, 0x12, 0xc5, 0x54, 0x66, 0xf6, 0x3d, 0x4a,
	0xf0, 0xc3, 0xc9, 0xfa, 0xc1, 0x80, 0x57, 0x6c, 0xd2, 0xa6, 0x91, 0x20, 0x5c, 0x9f, 0x73, 0x27,
	0x9c, 0x75, 0x59, 0x84, 0x7d, 0x54, 0x86, 0x5b, 0x82, 0x0a, 0x9f, 0xe8, 0x89, 0x8a, 0x1f, 0xd0,
	0x16, 0x98, 0x2d, 0x12, 0x79, 0x9c, 0x76, 0x65, 0x7e, 0x6a, 0x96, 0x8a, 0x76, 0x3a, 0x84, 0x8e,
	0xc0, 0xe4, 0x34, 0xea, 0x38, 0x5d, 0x35, 0xa3, 0x6a, 0x98, 0xcc, 0x9d, 0x37, 0xad, 0x9b, 0x37,
	0x85, 0x75, 0xe3, 0xbc, 0x6f, 0xe4, 0x9f, 0x3c, 0xdd, 0x5c, 0xb0, 0x81, 0x0f, 0x22, 0x5a, 0xe7,
	0x4f, 0x06, 0x6c, 0x24, 0x3a, 0x87, 0x73, 0x36, 0xb3, 0xd4, 0x47, 0xe3, 0xa4, 0x6e, 0x8f, 0x93,
	0x3a, 0xee, 0xf8, 0xf9, 0x5f, 0xb5, 0x3f, 0x1a, 0xf0, 0x6a, 0x93, 0x88, 0x1b, 0xe9, 0xbd, 0x94,
	0xa5, 0xfd, 0xc5, 0x80, 0xcd, 0x26, 0x11, 0xe3, 0x12, 0x7c, 0x59, 0xeb, 0xeb, 0xc3, 0xbd, 0x06,
	0x16, 0xde, 0xd9, 0x4d, 0xbf, 0xf0, 0x4c, 0x81, 0x8c, 0xad, 0xdc, 0xec, 0x05, 0xfa, 0xd9, 0x80,
	0xd7, 0xd4, 0xbf, 0x7b, 0x31, 0x5b, 0x3a, 0x07, 0xc5, 0x1c, 0xee, 0x2b, 0xc1, 0x63, 0xef, 0xcc,
	0x47, 0xe3, 0x4a, 0x34, 0xfb, 0x9e, 0xfc, 0x6a, 0xc0, 0x1b, 0x49, 0x95, 0x5e, 0x4c, 0x2f, 0xcd,
	0x47, 0xf7, 0x3f, 0x06, 0x94, 0x4e, 0x99, 0xc0, 0x7e, 0x62, 0xf3, 0x9a, 0x43, 0xcb, 0x19, 0x5f,
	0x5b, 0x4a, 0x67, 0xc3, 0x92, 0xf8, 0x0c, 0x17, 0x78, 0x62, 0x51, 0xe3, 0x6b, 0xeb, 0x03, 0x80,
	0xc4, 0x0c, 0x68, 0x03, 0x62, 0xee, 0xdc, 0xb7, 0x62, 0xa0, 0x25, 0x2d, 0xb1, 0xa5, 0x2d, 0xb1,
	0xb5, 0xcb, 0x68, 0xa8, 0xc5, 0x16, 0x83, 0xd8, 0x00, 0x90, 0x16, 0xfa, 0x08, 0x4c, 0x75, 0xd9,
	0x49, 0xbf, 0x46, 0x5a, 0x7a, 0x90, 0x9e, 0x4b, 0x00, 0x12, 0xd3, 0x50, 0x10, 0x9d, 0xed, 0xa5,
	0x01, 0xe6, 0x09, 0x63, 0x83, 0x64, 0x47, 0x75, 0x19, 0x99, 0x75, 0xbd, 0x0f, 0x85, 0xc4, 0x5c,
	0x4f, 0x98, 0x54, 0xf2, 0xfe, 0xdc, 0x52, 0xba, 0x07, 0xab, 0x1f, 0x7b, 0x1e, 0xeb, 0x85, 0xc9,
	0x70, 0x0e, 0xaf, 0xb6, 0x35, 0xb5, 0xb1, 0x29, 0x5f, 0xf6, 0x10, 0x96, 0x65, 0xba, 0x2d, 0xe2,
	0x8a, 0x49, 0x93, 0x2d, 0x04, 0x84, 0xef, 0x11, 0x57, 0xa0, 0x13, 0x58, 0x57, 0x7a, 0x87, 0x3e,
	0x91, 0x7e, 0x33, 0xf9, 0x5e, 0x22, 0x89, 0xdd, 0x1d, 0x81, 0x6a, 0x9d, 0x7f, 0x19, 0xb0, 0x2a,
	0xb7, 0x24, 0x25, 0xf3, 0x43, 0x80, 0x94, 0x1b, 0x9d, 0x50, 0x68, 0x0a, 0x32, 0x92, 0xe7, 0xe2,
	0x7c, 0xf2, 0xcc, 0xcd, 0x9a, 0xe7, 0xbf, 0x8b, 0x70, 0x47, 0x6f, 0x54, 0x2a, 0xd5, 0x0a, 0x14,
	0x70, 0x1c, 0xd4, 0xe7, 0x41, 0xf2, 0xf8, 0x4c, 0x11, 0x16, 0x67, 0x2b, 0x42, 0x6e, 0x3e, 0x45,
	0xc8, 0x4f, 0x5d, 0x04, 0xb4, 0x07, 0x2b, 0x3e, 0x8e, 0x84, 0x93, 0x78, 0x30, 0x65, 0xde, 0x27,
	0xe0, 0x2a, 0x49, 0xd4, 0x81, 0x06, 0xa1, 0x1d, 0xb8, 0xab, 0x58, 0x22, 0x22, 0x84, 0x4f, 0x02,
	0x12, 0x0a, 0xc7, 0xf5, 0x99, 0xd7, 0x51, 0x8e, 0x3d, 0x67, 0xaf, 0xcb, 0xc5, 0xe6, 0x60, 0xad,
	0x21, 0x97, 0xe2, 0xf2, 0x37, 0x0e, 0x9f, 0x5c, 0x55, 0x8d, 0xcb, 0xab, 0xaa, 0xf1, 0xe7, 0x55,
	0xd5, 0xf8, 0xf6, 0xba, 0xba, 0x70, 0x79, 0x5d, 0x5d, 0xf8, 0xfd, 0xba, 0xba, 0xf0, 0x65, 0x3d,
	0x75, 0xa2, 0x11, 0xbf, 0x1f, 0xd1, 0x5e, 0x10, 0x09, 0xe5, 0x5e, 0x6b, 0xc3, 0xaf, 0xff, 0x0b,
	0xfd, 0xfd, 0xaf, 0x0e, 0x38, 0x77, 0x49, 0x7d, 0xb3, 0xbf, 0xf7, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x89, 0x35, 0xc3, 0xb9, 0x1f, 0x10, 0x00, 0x00,
}

func (m *BackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RebackFee != nil {
		{
			size := m.RebackFee.Size()
			i -= size
			if _, err := m.RebackFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BuybackFee != nil {
		{
			size := m.BuybackFee.Size()
			i -= size
			if _, err := m.BuybackFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BurnFee != nil {
		{
			size := m.BurnFee.Size()
			i -= size
			if _, err := m.BurnFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMerMint != nil {
		{
			size := m.MaxMerMint.Size()
			i -= size
			if _, err := m.MaxMerMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxBacking != nil {
		{
			size := m.MaxBacking.Size()
			i -= size
			if _, err := m.MaxBacking.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BackingDenom) > 0 {
		i -= len(m.BackingDenom)
		copy(dAtA[i:], m.BackingDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.BackingDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterestFee != nil {
		{
			size := m.InterestFee.Size()
			i -= size
			if _, err := m.InterestFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.LiquidationFee != nil {
		{
			size := m.LiquidationFee.Size()
			i -= size
			if _, err := m.LiquidationFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CatalyticFuryRatio != nil {
		{
			size := m.CatalyticFuryRatio.Size()
			i -= size
			if _, err := m.CatalyticFuryRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BasicLoanToValue != nil {
		{
			size := m.BasicLoanToValue.Size()
			i -= size
			if _, err := m.BasicLoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.LoanToValue != nil {
		{
			size := m.LoanToValue.Size()
			i -= size
			if _, err := m.LoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LiquidationThreshold != nil {
		{
			size := m.LiquidationThreshold.Size()
			i -= size
			if _, err := m.LiquidationThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMerMint != nil {
		{
			size := m.MaxMerMint.Size()
			i -= size
			if _, err := m.MaxMerMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxCollateral != nil {
		{
			size := m.MaxCollateral.Size()
			i -= size
			if _, err := m.MaxCollateral.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterBackingProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterBackingProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterBackingProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterCollateralProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterCollateralProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterCollateralProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetBackingRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBackingRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetBackingRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCollateralRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCollateralRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCollateralRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchBackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchBackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchBackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetBackingRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetBackingRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetBackingRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchCollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchCollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetCollateralRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetCollateralRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetCollateralRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TotalBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryBurned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.MerMinted.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.BackingValue.Size()
		i -= size
		if _, err := m.BackingValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryBurned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Backing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.MerMinted.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AccountBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TotalCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryCollateralized.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.MerDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryCollateralized.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.MerDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AccountCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSettlementBlock != 0 {
		i = encodeVarintMaker(dAtA, i, uint64(m.LastSettlementBlock))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.LastInterest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.FuryCollateralized.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.MerDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMaker(dAtA []byte, offset int, v uint64) int {
	offset -= sovMaker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BackingDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxBacking != nil {
		l = m.MaxBacking.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxMerMint != nil {
		l = m.MaxMerMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BurnFee != nil {
		l = m.BurnFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BuybackFee != nil {
		l = m.BuybackFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RebackFee != nil {
		l = m.RebackFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *CollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxCollateral != nil {
		l = m.MaxCollateral.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxMerMint != nil {
		l = m.MaxMerMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationThreshold != nil {
		l = m.LiquidationThreshold.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LoanToValue != nil {
		l = m.LoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BasicLoanToValue != nil {
		l = m.BasicLoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.CatalyticFuryRatio != nil {
		l = m.CatalyticFuryRatio.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationFee != nil {
		l = m.LiquidationFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.InterestFee != nil {
		l = m.InterestFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *RegisterBackingProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *RegisterCollateralProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *SetBackingRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *SetCollateralRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *BatchBackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchSetBackingRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchCollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchSetCollateralRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *TotalBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingValue.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MerMinted.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.FuryBurned.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *PoolBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MerMinted.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.Backing.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.FuryBurned.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *AccountBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TotalCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MerDebt.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.FuryCollateralized.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *PoolCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Collateral.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MerDebt.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.FuryCollateralized.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *AccountCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MerDebt.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.FuryCollateralized.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.LastInterest.Size()
	n += 1 + l + sovMaker(uint64(l))
	if m.LastSettlementBlock != 0 {
		n += 1 + sovMaker(uint64(m.LastSettlementBlock))
	}
	return n
}

func sovMaker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMaker(x uint64) (n int) {
	return sovMaker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackingDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBacking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxBacking = &v
			if err := m.MaxBacking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMerMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxMerMint = &v
			if err := m.MaxMerMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BurnFee = &v
			if err := m.BurnFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuybackFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BuybackFee = &v
			if err := m.BuybackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebackFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RebackFee = &v
			if err := m.RebackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCollateral", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxCollateral = &v
			if err := m.MaxCollateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMerMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxMerMint = &v
			if err := m.MaxMerMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationThreshold = &v
			if err := m.LiquidationThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LoanToValue = &v
			if err := m.LoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicLoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BasicLoanToValue = &v
			if err := m.BasicLoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalyticFuryRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.CatalyticFuryRatio = &v
			if err := m.CatalyticFuryRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationFee = &v
			if err := m.LiquidationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.InterestFee = &v
			if err := m.InterestFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterBackingProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterBackingProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterBackingProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterCollateralProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterCollateralProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterCollateralProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBackingRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBackingRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBackingRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCollateralRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCollateralRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCollateralRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchBackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchBackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchBackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, BackingRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetBackingRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetBackingRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetBackingRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, BackingRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, CollateralRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetCollateralRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, CollateralRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerMinted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryBurned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerMinted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Backing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryBurned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryCollateralized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryCollateralized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryCollateralized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryCollateralized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryCollateralized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryCollateralized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastInterest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastInterest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSettlementBlock", wireType)
			}
			m.LastSettlementBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSettlementBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMaker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMaker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMaker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMaker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMaker = fmt.Errorf("proto: unexpected end of group")
)
